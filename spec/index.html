<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Kevin Huck (khuck@cs.uoregon.edu)" /><link rel="canonical" href="http://khuck.github.io/xpress-apex/spec/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>API Specification - APEX</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "API Specification";
        var mkdocs_page_input_path = "spec.md";
        var mkdocs_page_url = "/xpress-apex/spec/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> APEX
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../quickstarthpx/">Quick Start (HPX)</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../quickstart/">Quick Start (standalone)</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../feature/">Feature Overview</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../install/">Installation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../usage/">Usage</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../environment/">Useful Environment Variables</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">API Specification</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#read_me_first">READ ME FIRST!</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#a_note_about_c">A note about C++</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#terminology">Terminology</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#c_example">C example</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#c_example_1">C++ example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#constants_types_and_enumerations">Constants, types and enumerations</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#constants">Constants</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pre-defined_types">Pre-defined types</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#enumerations">Enumerations</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data_structures_and_classes">Data structures and classes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#environment_variables">Environment variables</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#general_utility_functions">General Utility functions</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#finalization">Finalization</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#cleanup">Cleanup</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#setting_node_id">Setting node ID</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#registering_threads">Registering threads</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exiting_a_thread">Exiting a thread</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#getting_the_apex_version">Getting the APEX version</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#getting_the_apex_settings">Getting the APEX settings</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#basic_measurement_functions_introspection">Basic measurement Functions (introspection)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#starting_a_timer">Starting a timer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#stopping_a_timer">Stopping a timer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#yielding_a_timer">Yielding a timer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#resuming_a_timer">Resuming a timer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating_a_new_task_dependency">Creating a new task dependency</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#sampling_a_value">Sampling a value</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#setting_the_os_thread_state">Setting the OS thread state</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#policy-related_methods_adaptation">Policy-related methods (adaptation)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#registering_an_event-based_policy_function">Registering an event-based policy function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#registering_a_periodic_policy">Registering a periodic policy</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#de-registering_a_policy">De-registering a policy</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#registering_a_custom_event">Registering a custom event</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#trigger_a_custom_event">Trigger a custom event</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#request_a_profile_from_apex">Request a profile from APEX</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reset_a_profile">Reset a profile</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#concurrency_throttling_policy_functions">Concurrency Throttling Policy Functions</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#setup_tuning_for_adaptation">Setup tuning for adaptation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#get_the_current_thread_cap">Get the current thread cap</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#set_the_current_thread_cap">Set the current thread cap</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#event-based_api_ocr_legion_support_-_tbd">Event-based API (OCR, Legion support - TBD)</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../refman/">API Doxygen Reference</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">APEX</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>API Specification</li>
    <li class="wy-breadcrumbs-aside">
          <a href="http://github.com/khuck/xpress-apex/edit/master/docs/spec.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="apex_specification_draft">APEX Specification <em>(DRAFT)</em><a class="headerlink" href="#apex_specification_draft" title="Permanent link">&para;</a></h1>
<p>*...to be fully implemented in a future release.  While the following 
specification is slightly different than the current implementation,
the differences are minor. When in doubt, the current implementation
is documented by Doxygen, and is available here:
<a href="http://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html">http://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/index.html</a>
<a href="http://www.nic.uoregon.edu/~khuck/apex_docs/doc/refman.pdf">http://www.nic.uoregon.edu/~khuck/apex_docs/doc/refman.pdf</a>
*</p>
<h2 id="read_me_first">READ ME FIRST!<a class="headerlink" href="#read_me_first" title="Permanent link">&para;</a></h2>
<p>The API specification is provided for users who wish to instrument their
own applications, or who wish to instrument a runtime. Please note that 
the <a href="../usage/#hpx-louisiana-state-university">HPX</a>,
<a href="../usage/#hpx-5-indiana-university">HPX-5</a> and
<a href="../usecases/#openmp-example">OpenMP</a> (using the LLVM OpenMP implementation
with draft OMPT support) runtimes have already been instrumented,
and that users typically do not have to make any calls to the APEX API, other
than to add application level timers or to write custom policy rules.</p>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>This page contains the API specification for APEX. The API specification
provides a high-level overview of the API and its functionality. The
implementation has Doxygen comments inserted, so for full implementation
details, please see the <a href="../refman/">API Reference Manual</a>.  </p>
<h3 id="a_note_about_c">A note about C++<a class="headerlink" href="#a_note_about_c" title="Permanent link">&para;</a></h3>
<p>The following specification contains both the C and the the C++ API. Typically,
the C++ names use overloading for different argument lists, and will replace
the <code>apex_</code> prefix with the <code>apex::</code> namespace. Because both APIs return 
handles to internal APEX objects, the type definitions of these objects 
use the C naming convention.</p>
<p>In addition to the simple API presented below, the C++ API includes scoped
timers and threads.  See <a href="http://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/namespaceapex.html">http://www.nic.uoregon.edu/~khuck/apex_docs/doc/html/namespaceapex.html</a>
for details.</p>
<h3 id="terminology">Terminology<a class="headerlink" href="#terminology" title="Permanent link">&para;</a></h3>
<p>Unfortunately, many terms in Computer Science are overloaded. The following definitions are in use in this document:</p>
<p><strong>Thread</strong>: an operating system (OS) thread of execution. For example, Posix threads (pthreads).  </p>
<p><strong>Task</strong>: a scheduled unit of work, such as an OpenMP task or an HPX thread. APEX timers are typically used to measure tasks.</p>
<h3 id="c_example">C example<a class="headerlink" href="#c_example" title="Permanent link">&para;</a></h3>
<p>The following is a very small C program that uses the APEX API. For more
examples, please see the programs in the <code>src/examples</code> and <code>src/unit_tests/C</code>
directories of the APEX source code.</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &quot;apex.h&quot;

int foo(int i) {
    /* start an APEX timer for the function foo */
    apex_profiler_handle profiler = apex_start(APEX_FUNCTION_ADDRESS, &amp;foo);
    int j = i * i;
    /* stop the APEX timer */
    apex_stop(profiler);
    return j;
}

int main (int argc, char** argv) {
    /* initialize APEX */
    apex_init(&quot;apex_start unit test&quot;);
    /* start a timer, passing in the address of the main function */
    apex_profiler_handle profiler = apex_start(APEX_FUNCTION_ADDRESS, &amp;main);
    int i,j = 0;
    for (i = 0 ; i &lt; 3 ; i++) {
        j += foo(i);
    }
    /* stop the timer */
    apex_stop(profiler);
    /* finalize APEX */
    apex_finalize();
    /* free all memory allocated by APEX */
    apex_cleanup();
    return 0;
}
</code></pre>
<h3 id="c_example_1">C++ example<a class="headerlink" href="#c_example_1" title="Permanent link">&para;</a></h3>
<p>The following is a slightly more complicated C++ pthread program that uses the
APEX API. For more examples, please see the programs in the <code>src/examples</code> and
<code>src/unit_tests/C++</code> directories of the APEX source code.</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &quot;apex_api.hpp&quot;

void* someThread(void* tmp)
{
    int* tid = (int*)tmp;
    char name[32];
    sprintf(name, &quot;worker thread %d&quot;, *tid);
    /* Register this thread with APEX */
    apex::register_thread(name);
    /* Start a timer */
    apex::profiler* p = apex::start((apex_function_address)&amp;someThread);
    /* ... */
    /* do some computation */
    /* ... */
    /* stop the timer */
    apex::stop(p);
    /* tell APEX that this thread is exiting */
    apex::exit_thread();
    return NULL;
}

int main (int argc, char** argv) {
    /* initialize APEX */
    apex::init(&quot;apex::start unit test&quot;);
    /* set our node ID */
    apex::set_node_id(0);
    /* start a timer */
    apex::profiler* p = apex::start(&quot;main&quot;);
    /* Spawn two threads */
    pthread_t thread[2];
    int tid = 0;
    pthread_create(&amp;(thread[0]), NULL, someThread, &amp;tid);
    int tid2 = 1;
    pthread_create(&amp;(thread[1]), NULL, someThread, &amp;tid2);
    /* wait for the threads to finish */
    pthread_join(thread[0], NULL);
    pthread_join(thread[1], NULL);
    /* stop our main timer */
    apex::stop(p);
    /* finalize APEX */
    apex::finalize();
    /* free all memory allocated by APEX */
    apex::cleanup();
    return 0;
}
</code></pre>
<h2 id="constants_types_and_enumerations">Constants, types and enumerations<a class="headerlink" href="#constants_types_and_enumerations" title="Permanent link">&para;</a></h2>
<h3 id="constants">Constants<a class="headerlink" href="#constants" title="Permanent link">&para;</a></h3>
<pre><code class="language-c">/** A null pointer representing an APEX profiler handle.
 * Used when a null APEX profile handle is to be passed in to
 * apex::stop when the profiler object was not retained locally.
 */
#define APEX_NULL_PROFILER_HANDLE (apex_profiler_handle)(NULL) // for comparisons

#define APEX_MAX_EVENTS 128 /*!&lt; The maximum number of event types. Allows for ~20 custom events. */

#define APEX_NULL_FUNCTION_ADDRESS 0L // for comparisons
</code></pre>
<h3 id="pre-defined_types">Pre-defined types<a class="headerlink" href="#pre-defined_types" title="Permanent link">&para;</a></h3>
<pre><code class="language-c">/** The address of a C++ object in APEX.
 * Not useful for the caller that gets it back, but required
 * for stopping the timer later.
 */
typedef uintptr_t apex_profiler_handle; // address of internal C++ object

/** Not useful for the caller that gets it back, but required
 * for deregistering policies after registration.
 */
typedef uintptr_t apex_policy_handle; // address of internal C++ object

/** Rather than use void pointers everywhere, be explicit about
 * what the functions are expecting.
 */
typedef uintptr_t apex_function_address; // generic function pointer
</code></pre>
<h3 id="enumerations">Enumerations<a class="headerlink" href="#enumerations" title="Permanent link">&para;</a></h3>
<pre><code class="language-c">/**
 * Typedef for enumerating the different timer types
 */
typedef enum _apex_profiler_type {
    APEX_FUNCTION_ADDRESS = 0, /*!&lt; The ID is a function (or instruction) address */
    APEX_NAME_STRING,          /*!&lt; The ID is a character string */
    APEX_FUNCTOR               /*!&lt; C++ Object with the () operator defined */
} apex_profiler_type;

/**
 * Typedef for enumerating the different event types
 */
typedef enum _event_type {
  APEX_INVALID_EVENT = -1,
  APEX_STARTUP = 0,        /*!&lt; APEX is initialized */
  APEX_SHUTDOWN,       /*!&lt; APEX is terminated */
  APEX_NEW_NODE,       /*!&lt; APEX has registered a new process ID */
  APEX_NEW_THREAD,     /*!&lt; APEX has registered a new OS thread */
  APEX_EXIT_THREAD,    /*!&lt; APEX has exited an OS thread */
  APEX_START_EVENT,    /*!&lt; APEX has processed a timer start event */
  APEX_RESUME_EVENT,   /*!&lt; APEX has processed a timer resume event (the number
                           of calls is not incremented) */
  APEX_STOP_EVENT,     /*!&lt; APEX has processed a timer stop event */
  APEX_YIELD_EVENT,    /*!&lt; APEX has processed a timer yield event */
  APEX_SAMPLE_VALUE,   /*!&lt; APEX has processed a sampled value */
  APEX_PERIODIC,       /*!&lt; APEX has processed a periodic timer */
  APEX_CUSTOM_EVENT_1,   /*!&lt; APEX has processed a custom event - useful for large
                           granularity application control events */
  APEX_CUSTOM_EVENT_2, // these are just here for padding, and so we can
  APEX_CUSTOM_EVENT_3, // test with them.
  APEX_CUSTOM_EVENT_4,
  APEX_CUSTOM_EVENT_5,
  APEX_CUSTOM_EVENT_6,
  APEX_CUSTOM_EVENT_7,
  APEX_CUSTOM_EVENT_8,
  APEX_UNUSED_EVENT = APEX_MAX_EVENTS // can't have more custom events than this
} apex_event_type;

/** 
 * Typedef for enumerating the OS thread states. 
 */
typedef enum _thread_state {
    APEX_IDLE,          /*!&lt; Thread is idle */
    APEX_BUSY,          /*!&lt; Thread is working */
    APEX_THROTTLED,     /*!&lt; Thread is throttled (sleeping) */
    APEX_WAITING,       /*!&lt; Thread is waiting for a resource */
    APEX_BLOCKED        /*!&lt; Thread is otherwise blocked */
} apex_thread_state;

/**
 * Typedef for enumerating the different optimization strategies
 * for throttling.
 */
typedef enum {APEX_MAXIMIZE_THROUGHPUT,   /*!&lt; maximize the number of calls to a
                                              timer/counter */
              APEX_MAXIMIZE_ACCUMULATED,  /*!&lt; maximize the accumulated value of
                                              a timer/counter */
              APEX_MINIMIZE_ACCUMULATED   /*!&lt; minimize the accumulated value of
                                              a timer/counter */
} apex_optimization_criteria_t;

/**
 * Typedef for enumerating the different optimization methods
 * for throttling.
 */
typedef enum {APEX_SIMPLE_HYSTERESIS,      /*!&lt; optimize using sliding window of
                                               historical observations. A running
                                               average of the most recent N observations
                                               are used as the measurement. */
              APEX_DISCRETE_HILL_CLIMBING, /*!&lt; Use a discrete hill climbing algorithm
                                               for optimization */
              APEX_ACTIVE_HARMONY          /*!&lt; Use Active Harmony for optimization. */
} apex_optimization_method_t;

/** The type of a profiler object
 * 
 */
typedef enum _profile_type {
  APEX_TIMER,        /*!&lt; This profile is a instrumented timer */
  APEX_COUNTER       /*!&lt; This profile is a sampled counter */
} apex_profile_type;


</code></pre>
<h2 id="data_structures_and_classes">Data structures and classes<a class="headerlink" href="#data_structures_and_classes" title="Permanent link">&para;</a></h2>
<pre><code class="language-c">/** 
 * The APEX context when an event occurs. This context will be passed to 
 * any policies registered for this event.
 */
typedef struct _context {
    apex_event_type event_type;        /*!&lt; The type of the event currently
                                           processing */
    apex_policy_handle* policy_handle; /*!&lt; The policy handle for the current
                                           policy function */
    void * data;  /*!&lt; Data associated with the event, such as the custom_data
                       for a custom_event */
} apex_context;

/**
 * The profile object for a timer in APEX. 
 * Returned by the apex_get_profile() call.
 */
typedef struct _profile {
    double calls;         /*!&lt; Number of times a timer was called, or the number
                              of samples collected for a counter */
    double accumulated;   /*!&lt; Accumulated values for all calls/samples */
    double sum_squares;   /*!&lt; Running sum of squares calculation for all
                              calls/samples */
    double minimum;       /*!&lt; Minimum value seen by the timer or counter */
    double maximum;       /*!&lt; Maximum value seen by the timer or counter */
    apex_profile_type type; /*!&lt; Whether this is a timer or a counter */
    double papi_metrics[8];  /*!&lt; Array of accumulated PAPI hardware metrics */
} apex_profile;

/**
 * The APEX tuning request structures.
 */

typedef struct _apex_param {
    char * init_value;          /*!&lt; Initial value */
    const char * value;         /*!&lt; Current value */
    int num_possible_values;    /*!&lt; Number of possible values */
    char * possible_values[];
} apex_param_struct;

typedef struct _apex_tuning_request {
    char * name;                                      /*!&lt; Tuning request name */
    double (*metric)(void);                           /*!&lt; function to return the address of the output parameter */
    int num_params;                                   /*!&lt; number of tuning input parameters */
    char * param_names[];                             /*!&lt; the input parameter names */
    apex_param_struct * params[];                     /*!&lt; the input parameters */
    apex_event_type trigger;                          /*!&lt; the event that triggers the tuning update */
    apex_tuning_session_handle tuning_session_handle; /*!&lt; the Active Harmony tuning session handle */
    bool running;                                     /*!&lt; the current state of the tuning */
    apex_ah_tuning_strategy strategy;                 /*!&lt; the requested Active Harmony tuning strategy */
} apex_tuning_request_struct;
</code></pre>
<h2 id="environment_variables">Environment variables<a class="headerlink" href="#environment_variables" title="Permanent link">&para;</a></h2>
<p>Please see the <a href="../environment/">environment variables</a> section of the
documentation. Please note that all environment variables can also be
queried or set at runtime with associated API calls. For example, the 
APEX_CSV_OUTPUT variable can also be set/queried with:</p>
<pre><code class="language-c">void apex_set_csv_output (int);
int apex_get_csv_output (void);
</code></pre>
<h2 id="general_utility_functions">General Utility functions<a class="headerlink" href="#general_utility_functions" title="Permanent link">&para;</a></h2>
<h3 id="initialization">Initialization<a class="headerlink" href="#initialization" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::init (const char *thread_name);
</code></pre>
<pre><code class="language-c">/* C */
void apex_init (const char *thread_name);
</code></pre>
<p>APEX initialization is required to set up data structures and spawn the
necessary helper threads, including the background system state query thread,
the policy engine thread, and the profile handler thread. The thread name
parameter will be used as the top-level timer for the the main thread of
execution.</p>
<h3 id="finalization">Finalization<a class="headerlink" href="#finalization" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::finalize (void);
</code></pre>
<pre><code class="language-c">/* C */
void apex_finalize (void);
</code></pre>
<p>APEX finalization is required to format any desired output (screen, csv,
profile, etc.) and terminate all APEX helper threads. No memory is freed at
this point - that is done by the <code>apex_cleanup()</code> call.  The reason for this is
that applications may want to perform reporting after finalization, so the
performance state of the application should still exist. </p>
<h3 id="cleanup">Cleanup<a class="headerlink" href="#cleanup" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::cleanup (void);
</code></pre>
<pre><code class="language-c">/* C */
void apex_cleanup (void);
</code></pre>
<p>APEX cleanup frees all memory associated with APEX. </p>
<h3 id="setting_node_id">Setting node ID<a class="headerlink" href="#setting_node_id" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::set_node_id (const uint64_t id);
</code></pre>
<pre><code class="language-c">/* C */
void apex_set_node_id (const uint64_t id);
</code></pre>
<p>When running in distributed environments, assign the specified id number as the
APEX node ID. This can be an MPI rank or an HPX locality, for example. </p>
<h3 id="registering_threads">Registering threads<a class="headerlink" href="#registering_threads" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::register_thread (const std::string &amp;name);
</code></pre>
<pre><code class="language-c">/* C */
void apex_register_thread (const char *name);
</code></pre>
<p>Register a new OS thread with APEX.  This method should be called whenever a
new OS thread is spawned by the application or the runtime.  An empty string
or null string is valid input.</p>
<h3 id="exiting_a_thread">Exiting a thread<a class="headerlink" href="#exiting_a_thread" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::exit_thread (void);
</code></pre>
<pre><code class="language-c">/* C */
void apex_exit_thread (void);
</code></pre>
<p>Before any thread other than the main thread of execution exits, notify APEX
that the thread is exiting. The main thread should not call this function, but
apex_finalize instead. Exiting the thread will trigger an event in APEX, so 
any policies associated with a thread exit will be executed.</p>
<h3 id="getting_the_apex_version">Getting the APEX version<a class="headerlink" href="#getting_the_apex_version" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
std::string &amp; apex::version (void);
</code></pre>
<pre><code class="language-c">/* C */
const char * apex_version (void);
</code></pre>
<p>Return the APEX version as a string.</p>
<h3 id="getting_the_apex_settings">Getting the APEX settings<a class="headerlink" href="#getting_the_apex_settings" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
std::string &amp; apex::get_options (void);
</code></pre>
<pre><code class="language-c">/* C */
const char * apex_get_options (void);
</code></pre>
<p>Return the current APEX options as a string.</p>
<h2 id="basic_measurement_functions_introspection">Basic measurement Functions (introspection)<a class="headerlink" href="#basic_measurement_functions_introspection" title="Permanent link">&para;</a></h2>
<h3 id="starting_a_timer">Starting a timer<a class="headerlink" href="#starting_a_timer" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex_profiler_handle apex::start (const std::string &amp;timer_name);
apex_profiler_handle apex::start (const apex_function_address function_address);
</code></pre>
<pre><code class="language-c">/* C */
apex_profiler_handle apex_start (apex_profiler_type type, const void * identifier);
</code></pre>
<p>Create an APEX timer and start it. An APEX profiler object is returned,
containing an identifier that APEX uses to stop the timer.  The timer is either
identified by a name or a function/task instruction pointer address.</p>
<h3 id="stopping_a_timer">Stopping a timer<a class="headerlink" href="#stopping_a_timer" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::stop (apex_profiler_handle the_profiler);
</code></pre>
<pre><code class="language-c">/* C */
void apex_stop (apex_profiler_handle the_profiler);
</code></pre>
<p>The timer associated with the profiler object is stopped and placed on an
internal queue to be processed by the profiler handler thread in the
background.  The profiler object is flagged as "stopped", so that when the
profiler is processed the call count for this particular timer will be
incremented by 1, <em>unless</em> the timer was started by <code>apex_resume()</code> (see
below). The profiler handle will be freed internally by APEX after processing.</p>
<h3 id="yielding_a_timer">Yielding a timer<a class="headerlink" href="#yielding_a_timer" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::yield (apex_profiler_handle the_profiler);
</code></pre>
<pre><code class="language-c">/* C */
void apex_yield (apex_profiler_handle the_profiler);
</code></pre>
<p>The timer associated with the profiler object is stopped and placed on an
internal queue to be processed by the profiler handler thread in the
background.  The profiler object is flagged as <em>NOT stopped</em>, so that when the
profiler is processed the call count will NOT be incremented.  An application
using apex_yield should not use apex_resume to restart the timer, it should use
apex_start. <code>apex_yield()</code> is intended for situations when the completion state
of the task is known and the state is <em>not complete</em>.
below). The profiler handle will be freed internally by APEX after processing.</p>
<h3 id="resuming_a_timer">Resuming a timer<a class="headerlink" href="#resuming_a_timer" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex_profiler_handle apex::resume (const std::string &amp;timer_name);
apex_profiler_handle apex::resume (const apex_function_address function_address);
</code></pre>
<pre><code class="language-c">/* C */
apex_profiler_handle apex_resume (apex_profiler_type type, const void * identifier);
</code></pre>
<p>Create an APEX timer and start it. An APEX profiler object is returned,
containing an identifier that APEX uses to stop the timer.  The profiler is
flagged as <em>NOT a new task</em>, so that when it is stopped by apex_stop the call
count for this particular timer will not be incremented. Apex_resume is intended
for situations when the completion state of a task is NOT known when control
is returned to the task scheduler, but is known when an interrupted task is 
resumed.</p>
<h3 id="creating_a_new_task_dependency">Creating a new task dependency<a class="headerlink" href="#creating_a_new_task_dependency" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::new_task (std::string &amp; name, const void * task_id);
void apex::new_task (const apex_function_address function_address, const void * task_id);
</code></pre>
<pre><code class="language-c">/* C */
void apex_new_task (apex_profiler_type type, const void * identifier, const void * task_id)
</code></pre>
<p>Register the creation of a new task. This is used to track task dependencies in
APEX. APEX assumes that the current APEX profiler refers to the task that is
the parent of this new task. The task_info object is a generic pointer to
whatever data might need to be passed to a policy executed on when a new task
is created.</p>
<h3 id="sampling_a_value">Sampling a value<a class="headerlink" href="#sampling_a_value" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::sample_value (const std::string &amp; name, const double value)
</code></pre>
<pre><code class="language-c">/* C */
void apex_sample_value (const char * name, const double value);
</code></pre>
<p>Record a measurement of the specified counter with the specified value. For
example, "bytes transferred" and "1024".</p>
<h3 id="setting_the_os_thread_state">Setting the OS thread state<a class="headerlink" href="#setting_the_os_thread_state" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::set_state (apex_thread_state state);
</code></pre>
<pre><code class="language-c">/* C */
void apex_set_state (apex_thread_state state);
</code></pre>
<p>Set the state of the current OS thread.  States can include things like idle,
busy, waiting, throttled, blocked.</p>
<h2 id="policy-related_methods_adaptation">Policy-related methods (adaptation)<a class="headerlink" href="#policy-related_methods_adaptation" title="Permanent link">&para;</a></h2>
<h3 id="registering_an_event-based_policy_function">Registering an event-based policy function<a class="headerlink" href="#registering_an_event-based_policy_function" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex_policy_handle apex::register_policy (const apex_event_type when, std::function&lt;int(apex_context const&amp;)&gt; f);
std::set&lt;apex_policy_handle&gt; apex::register_policy (std::set&lt;apex_event_type&gt; when, std::function&lt;int(apex_context const&amp;)&gt; f);
</code></pre>
<pre><code class="language-c">/* C */
apex_policy_handle apex_register_policy (const apex_event_type when, int(*f)(apex_context const&amp;));
</code></pre>
<p>APEX provides the ability to call an application-specified function when
certain events occur in the APEX library, or periodically. This assigns the
passed in function to the event, so that when that event occurs in APEX, the
function is called. The context for the event will be passed to the registered
function. A set of events can also be used to register a policy function, which will
return a set of policy handles. When any event in the set occurs, the function will
be called.</p>
<h3 id="registering_a_periodic_policy">Registering a periodic policy<a class="headerlink" href="#registering_a_periodic_policy" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex_policy_handle apex::register_periodic_policy(const unsigned long period, std::function&lt;int(apex_context const&amp;)&gt; f);
</code></pre>
<pre><code class="language-c">/* C */
apex_policy_handle apex_register_periodic_policy (const unsigned long period, int(*f)(apex_context const&amp;));
</code></pre>
<p>Apex provides the ability to call an application-specified function
periodically. This method assigns the passed in function to be called on a
periodic basis. The context for the event will be passed to the registered
function.  The period units are in microseconds (us).</p>
<h3 id="de-registering_a_policy">De-registering a policy<a class="headerlink" href="#de-registering_a_policy" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex::deregister_policy (apex_policy_handle handle);
</code></pre>
<pre><code class="language-c">/* C */
apex_deregister_policy (apex_policy_handle handle);
</code></pre>
<p>Remove the specified policy so that it will no longer be executed, whether it
is event-based or periodic. The calling code should not try to dereference the
policy handle after this call, as the memory pointed to by the handle will be
freed.</p>
<h3 id="registering_a_custom_event">Registering a custom event<a class="headerlink" href="#registering_a_custom_event" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex_event_type apex::register_custom_event (const std::string &amp; name);
</code></pre>
<pre><code class="language-c">/* C */
apex_event_type apex_register_custom_event (const char * name);
</code></pre>
<p>Register a new event type with APEX.</p>
<h3 id="trigger_a_custom_event">Trigger a custom event<a class="headerlink" href="#trigger_a_custom_event" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::custom_event (apex_event_type event_type, const void * event_data);
</code></pre>
<pre><code class="language-c">/* C */
void apex_custom_event (const char * name, const void * event_data);
</code></pre>
<p>Trigger a custom event.  This function will pass a custom event to the APEX
event listeners. Each listeners' custom event handler will handle the custom
event. Policy functions will be passed the custom event name in the event
context.  The event data pointer is to be used to pass memory to the policy
function from the code that triggered the event.</p>
<h3 id="request_a_profile_from_apex">Request a profile from APEX<a class="headerlink" href="#request_a_profile_from_apex" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex_profile * apex::get_profile (const std::string &amp; name);
apex_profile * apex::get_profile (const apex_function_address function_address);
</code></pre>
<pre><code class="language-c">/* C */
apex_profile * apex_get_profile (apex_profiler_type type, const void * identifier)
</code></pre>
<p>This function will return the current profile for the specified identifier.
Because profiles are updated out-of-band, it is possible that this profile
values are out of date. This profile can be either a timer or a sampled value.</p>
<h3 id="reset_a_profile">Reset a profile<a class="headerlink" href="#reset_a_profile" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::reset (const std::string &amp; timer_name);
void apex::reset (const apex_function_address function_address);
</code></pre>
<pre><code class="language-c">/* C */
void apex_reset (apex_profiler_type type, const void * identifier)
</code></pre>
<p>This function will reset the profile associated with the specified timer or
counter id to zero.  If the identifier is null, all timers and counters will be
reset.</p>
<h2 id="concurrency_throttling_policy_functions">Concurrency Throttling Policy Functions<a class="headerlink" href="#concurrency_throttling_policy_functions" title="Permanent link">&para;</a></h2>
<h3 id="setup_tuning_for_adaptation">Setup tuning for adaptation<a class="headerlink" href="#setup_tuning_for_adaptation" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
apex_tuning_session_handle setup_custom_tuning(apex_tuning_request &amp; request);
</code></pre>
<pre><code class="language-c">apex_tuning_session_handle setup_custom_tuning(apex_tuning_request * request);
</code></pre>
<p>Setup tuning of specified parameters to optimize for a custom metric, using
multiple input criteria.  This function will initialize a policy to optimize a
custom metric, using the list of tunable parameters. The system tries to
minimize the custom metric. After evaluating the state of the system, the
policy will assign new values to the inputs.</p>
<h3 id="get_the_current_thread_cap">Get the current thread cap<a class="headerlink" href="#get_the_current_thread_cap" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
int apex::get_thread_cap (void);
</code></pre>
<pre><code class="language-c">/* C */
int apex_get_thread_cap (void);
</code></pre>
<p>This function will return the current thread cap based on the throttling policy.</p>
<h3 id="set_the_current_thread_cap">Set the current thread cap<a class="headerlink" href="#set_the_current_thread_cap" title="Permanent link">&para;</a></h3>
<pre><code class="language-c++">/* C++ */
void apex::set_thread_cap (int new_cap);
</code></pre>
<pre><code class="language-c">/* C */
void apex_set_thread_cap (int new_cap);
</code></pre>
<p>This function will set the current thread cap based on an external throttling policy.</p>
<h2 id="event-based_api_ocr_legion_support_-_tbd">Event-based API (OCR, Legion support - <em>TBD</em>)<a class="headerlink" href="#event-based_api_ocr_legion_support_-_tbd" title="Permanent link">&para;</a></h2>
<p>The OCR and Legion runtimes teams have met to propose a common API for
measuring asynchronous task-based runtimes.
For more details, see <a href="https://github.com/khuck/xpress-apex/issues/37">https://github.com/khuck/xpress-apex/issues/37</a>.</p>
<pre><code class="language-c++">/* C++ */
apex::task_create (uint64_t parent_id)
apex::dependency_reached (uint64_t event_id, uint64_t data_id, uint64_t task_id, uint64_t parent_id, ?)
apex::task_ready (uint64_t why_ready)
apex::task_execute (uint64_t why_delay, const apex_function_address function)
apex::task_finished (uint64_t task_id)
apex::task_destroy (uint64_t task_id)
apex::data_create (uint64_t data_id)
apex::data_new_size (uint64_t data_id)
apex::data_move_from (uint64_t data_id, uint64_t target_location)
apex::data_move_to (uint64_t data_id, uint64_t source_location)
apex::data_replace (uint64_t data_id, uint64_t new_id)
apex::data_destroy (uint64_t data_id)
apex::event_create (uint64_t event_id, parent_task_id)
apex::event_add_dependency (uint64_t event_id, uint64_t data_event_task_id, uint64_t parent_task_id)
apex::event_trigger (uint64_t event_id)
apex::event_destroy (uint64_t event_id)
</code></pre>
<pre><code class="language-c">/* C API tbd */
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../environment/" class="btn btn-neutral float-left" title="Useful Environment Variables"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../refman/" class="btn btn-neutral float-right" title="API Doxygen Reference">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>(C) 2014-2021 University of Oregon, All Rights Reserved</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="http://github.com/khuck/xpress-apex" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../environment/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../refman/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
